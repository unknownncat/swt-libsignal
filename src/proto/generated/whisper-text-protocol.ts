/* eslint-disable */
// @generated by internal static protobuf compiler (ts-proto-compatible surface)

export interface WhisperMessage {
  readonly ephemeralKey?: Uint8Array;
  readonly counter?: number;
  readonly previousCounter?: number;
  readonly ciphertext?: Uint8Array;
}

export interface PreKeyWhisperMessage {
  readonly registrationId?: number;
  readonly preKeyId?: number;
  readonly signedPreKeyId?: number;
  readonly baseKey?: Uint8Array;
  readonly identityKey?: Uint8Array;
  readonly message?: Uint8Array;
}

export interface KeyExchangeMessage {
  readonly id?: number;
  readonly baseKey?: Uint8Array;
  readonly ephemeralKey?: Uint8Array;
  readonly identityKey?: Uint8Array;
  readonly baseKeySignature?: Uint8Array;
}

type DecodeTarget = Record<string, number | Uint8Array | undefined>;

function varintSize(value: number): number {
  let size = 1;
  while (value > 0x7f) {
    size++;
    value >>>= 7;
  }
  return size;
}

function writeVarint(out: Uint8Array, offset: number, value: number): number {
  while (value > 0x7f) {
    out[offset++] = (value & 0x7f) | 0x80;
    value >>>= 7;
  }
  out[offset++] = value;
  return offset;
}

function readVarint(input: Uint8Array, offset: number): readonly [number, number] {
  let value = 0;
  let shift = 0;
  let i = offset;
  while (i < input.length) {
    const b = input[i]!;
    value |= (b & 0x7f) << shift;
    i++;
    if ((b & 0x80) === 0) return [value >>> 0, i] as const;
    shift += 7;
  }
  throw new Error('Malformed varint');
}

function skipUnknown(type: number, input: Uint8Array, offset: number): number {
  if (type === 0) {
    const [, next] = readVarint(input, offset);
    return next;
  }
  if (type === 2) {
    const [len, next] = readVarint(input, offset);
    return next + len;
  }
  throw new Error(`Unsupported wire type: ${type}`);
}

function decodeMessage<T>(
  input: Uint8Array,
  bytesMap: Readonly<Record<number, keyof T>>,
  varintMap: Readonly<Record<number, keyof T>>,
): T {
  const target: DecodeTarget = {};
  let offset = 0;
  while (offset < input.length) {
    const [header, afterHeader] = readVarint(input, offset);
    const tag = header >>> 3;
    const wireType = header & 0x7;
    offset = afterHeader;

    const byteField = bytesMap[tag];
    if (wireType === 2 && byteField) {
      const [len, next] = readVarint(input, offset);
      const end = next + len;
      target[byteField as string] = input.subarray(next, end);
      offset = end;
      continue;
    }

    const varintField = varintMap[tag];
    if (wireType === 0 && varintField) {
      const [value, next] = readVarint(input, offset);
      target[varintField as string] = value;
      offset = next;
      continue;
    }

    offset = skipUnknown(wireType, input, offset);
  }

  return target as T;
}

function encodeFields(
  message: DecodeTarget,
  bytesFields: ReadonlyArray<readonly [number, string]>,
  varintFields: ReadonlyArray<readonly [number, string]>,
): Uint8Array {
  let size = 0;
  for (const [tag, key] of bytesFields) {
    const value = message[key];
    if (value instanceof Uint8Array) {
      size += varintSize((tag << 3) | 2) + varintSize(value.length) + value.length;
    }
  }
  for (const [tag, key] of varintFields) {
    const value = message[key];
    if (typeof value === 'number') {
      size += varintSize((tag << 3) | 0) + varintSize(value >>> 0);
    }
  }

  const out = new Uint8Array(size);
  let offset = 0;

  for (const [tag, key] of bytesFields) {
    const value = message[key];
    if (!(value instanceof Uint8Array)) continue;
    offset = writeVarint(out, offset, (tag << 3) | 2);
    offset = writeVarint(out, offset, value.length);
    out.set(value, offset);
    offset += value.length;
  }

  for (const [tag, key] of varintFields) {
    const value = message[key];
    if (typeof value !== 'number') continue;
    offset = writeVarint(out, offset, (tag << 3) | 0);
    offset = writeVarint(out, offset, value >>> 0);
  }

  return out;
}

export const WhisperMessageCodec = {
  encode(message: WhisperMessage): Uint8Array {
    return encodeFields(
      message as DecodeTarget,
      [
        [1, 'ephemeralKey'],
        [4, 'ciphertext'],
      ] as const,
      [
        [2, 'counter'],
        [3, 'previousCounter'],
      ] as const,
    );
  },
  decode(input: Uint8Array): WhisperMessage {
    return decodeMessage<WhisperMessage>(input, { 1: 'ephemeralKey', 4: 'ciphertext' }, { 2: 'counter', 3: 'previousCounter' });
  },
} as const;

export const PreKeyWhisperMessageCodec = {
  encode(message: PreKeyWhisperMessage): Uint8Array {
    return encodeFields(
      message as DecodeTarget,
      [
        [2, 'baseKey'],
        [3, 'identityKey'],
        [4, 'message'],
      ] as const,
      [
        [1, 'preKeyId'],
        [5, 'registrationId'],
        [6, 'signedPreKeyId'],
      ] as const,
    );
  },
  decode(input: Uint8Array): PreKeyWhisperMessage {
    return decodeMessage<PreKeyWhisperMessage>(
      input,
      { 2: 'baseKey', 3: 'identityKey', 4: 'message' },
      { 1: 'preKeyId', 5: 'registrationId', 6: 'signedPreKeyId' },
    );
  },
} as const;
